using System;

// Делегаты.
/// Это упрощенный предыдущий пример;  01:38:00
/// Данный пример показывает интересные функциональные стили, функциональные подходы в С#;
/// Пример показывает работу с делегатами, но  в то же время показывает, что не нужно ими злоупотреблять; Похоже на злоупотребление с тернарными операторами 
/// из примеров с курса Стартер.

namespace Delegates
{
    delegate MyDelegate Functional(MyDelegate delegate1, MyDelegate delegate2);   /// создаем класс-делегат с именем Functional; 
                                                                                  /// метод, который будет сообщен с экземпляром данного класса-делегата 
                                                                                  /// будет принимать 2 аргумента типа MyDelegate и возвращать значение 
                                                                                  /// типа MyDelegate, т.е. создавать новый экземпляр делегата ("чемодан");
    delegate string MyDelegate();  /// создаем класс-делегат с именем MyDelegate. 
                                   /// Метод, который будет сообщен с ним не будет ничего принимать и возвращать строковое значение.

    class Program
    {
        static void Main()
        {
            MyDelegate delegate1 = () => "Hello ", delegate2 = () => "world!";  /// множественное создание переменных типа MyDelegate;
                                                                                /// создаем 2 "чемодана", 2 готовых делегата; 
                                                                                /// создаем переменную с именем delegate2 типа MyDelegate и присваиваем ей ссылку на 
                                                                                /// экземпляр делегата, с которым сообщено лямбда-выражение, которое 
                                                                                /// возвращает "world";
                                                                                /// Здесь также используется ТЕХНИКА ПРЕДПОЛОЖЕНИЯ ДЕЛЕГАТОВ;

            Functional functional = delegate (MyDelegate d1, MyDelegate d2) { return delegate () { return d1.Invoke() + d2.Invoke(); }; };

            /// создаем экземпляр делегата Functional и сообщаем с ним метод, который создается с использованием синтаксиса анонимного метода (лямбда-метода);
            /// ниже показаны альтернативные, упрощенные варианты синтаксиса создания экземпляра делегата с лямбда-выражениями;

            //Functional functional = delegate(MyDelegate d1, MyDelegate d2) { return () => d1.Invoke() + d2.Invoke(); };
            
            /// Заменили лямбда-метод (анонимный метод) на лямбда-выражение;
            /// Было:   delegate () { return d1.Invoke() + d2.Invoke(); };
            /// Стало:           () => d1.Invoke() + d2.Invoke();

            //Functional functional = (MyDelegate d1, MyDelegate d2) => () => d1() + d2(); 
            
            /// Такой вариант хоть и является коротким, но для не подготовленного он не всегда удобный, не всегда удобочитаемый;
            /// () => d1() + d2(); - "чемодан" с делегатом типа MyDelegate;

            //Console.WriteLine((functional.Invoke(delegate1,delegate2)).Invoke()); /// вариант с визуализацией вызова метода Invoke();

            Console.WriteLine(functional(delegate1, delegate2)());  /// эта же запись в более нагядном виде представлена выше, также можно показать вот так: 
                                                                    /// functional(delegate1, delegate2) - это выражение дает новый "чемодан", новый экземпляр 
                                                                    /// делегата с типом класса-делегата MyDelegate, который готов к использованию на следующем шаге;
                                                                    /// В результате выражение трансформируется в следующий вид,
                                                                    /// Console.WriteLine(MyDelegate()) - вызываем вновь созданный делегат без параметров, 
                                                                    /// традиционный синтаксис обращения к делегату если не использовать Invoke();
            // Delay.
            Console.ReadKey();
        }
    }
}
/// Программист, который будет читать эту программу, потребуется потратить больше времени, чтобы вдуматься в данные конструкции, чем написавшему её разработчику.
/// Возможно имеет смысл делать конструкции более многословными синтаксически, но при этом они будут проще и легче воспринимаемы и читаемы;
/// 















