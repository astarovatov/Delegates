using System;

// Рекурсия в лямбда операторах.
/// Пример показывает как организовать рекурсивный вывод с использованием лямбда-операторов.

namespace Delegates
{
    delegate void MyDelegate(int argument);   /// создаем класс-делегат, с которым можно сообщить метод, принимающий один целочисленный агрумент и не 
                                              /// будет ничего возвращать;

    class Program
    {
        static void Main()
        {
            MyDelegate my = null; // Требуется обязательно присвоить null.

            // Требуется отдельное присвоение ссылки на делегат с сообщенным лямбда оператором,
            // в месте создания переменной, недопустимо сразу создавать лямбда оператор.
            /// т.е. вот так вызывать нельзя, будет ошибка: MyDelegate my = (int i) => { ... }
            /// Ведущий считает, что это скорее недоработка в системе компиляции, чем целенаправленное ограничение;

            my = (int i) =>    /// тип переменной можно не указывать, это не будет ошибкой, т.к. тип определается требованиями класса делегата выше. 
                               /// Но лучше оставить тип переменной (int i), чтобы код был очевиднее;
            {
                i--;
                Console.WriteLine("Begin {0}", i);

                if (i > 0)
                {
                    my(i);     /// рекурсивно вызываем себя, my.Invoke(i). Стандартная работа рекурсии, стек раскручивается и когда условие перестает удовлетворять
                               /// истинности стек сворачивается; В данной рекорсии 3 витка, 3 итерации (см. вызов ниже);
                }

                Console.WriteLine("End {0}", i);
            };                 /// опять-таки используется техника предположения делегата при работе с лямбда-оператором;

            my(3);  /// вызываем делегат

            // Delay.
            Console.ReadKey();
        }
    }
}
