using System;

// Делегаты.
/// Здесь описан ещё один функциональный подход в программировании с использованием делегатов.

namespace Delegates
{
    delegate Delegate3 Functional(Delegate1 delegate1, Delegate2 delegate2);  /// создаем класс-делегат с именем Functional; 
    delegate string Delegate1();
    delegate string Delegate2();
    delegate string Delegate3();

    class Program
    {
        public static Delegate3 MethodF(Delegate1 delegate1, Delegate2 delegate2) /// 2 "чемодана" передаем в качестве аргументов метода;
        {                                                                         /// на выходе получаем третий "чемодан".
            return delegate { return delegate1.Invoke() + delegate2.Invoke(); };  /// 01:34:20 - здесь использован анонимный метод без входный параметров. 
                                                                                  /// А мы анонимные методы ассоциируем с делегатами.
                                                                                  /// Говорим "анонимный метод", поразумеваем неявное создание 
                                                                                  /// экземпляра делегата, ПРЕДПОЛОЖЕНИЕ ДЕЛЕГАТА в случае использования
                                                                                  /// анонимных методов (см. пример: 005_Delegates (anonymous methods))

            /// Здесь происходит конкатенация возвращаемых значений методов, сообщенных с делегатами, с делегатом 1 (delegate1) и с делегатом 2 (delegate2);
            /// 01:37:15 - На 16-й строке мы возвращаем делегат с сообщенным лямбда-методом, который возвращает конкатенацию возвращаемых значений методов, 
            /// сообщенных с делегатами, которые поступают в качестве аргументов;
        }


        public static string Method1() { return "Hello "; }
        public static string Method2() { return "world!"; }

        static void Main()
        {
            Functional functional = new Functional(MethodF);   /// создаем чемодан (экземпляр делегата) Functional и сообщаем с ним метод, возвращаемым значением
                                                               /// которого является экземпляр типа делегата Delegate3, который в свою очередь представляет собой
                                                               /// "указатель" на метод без входных параметров и вовзращающий строковое значение ;

            Delegate3 delegate3 = functional.Invoke(new Delegate1(Method1), new Delegate2(Method2));   /// присваиваем переменной delegate3 возвращаемое значение
                                                                                                       /// метода MethodF, совмещенного с экземпляром functional 
                                                                                                       /// класса-делегата Delegate3.
                                                                                                       /// При обращении к делегату Functional передаем 2 входных 
                                                                                                       /// параметра, каждый из которых является экземпляром других
                                                                                                       /// классов-делегатов.

            /// В итоге переменная delegate3 содержит ссылку ("указатель") на анонимный метод, который не принимает входных аргументов и возвращает строку;
            /// Как видно, этот анонимный метод является возвращаемым значением метода MethodF, который был совмещен с экземпляром делегата Delegate3, functional;

            Console.WriteLine(delegate3.Invoke());

            // Delay.
            Console.ReadKey();
        }
    }
}
